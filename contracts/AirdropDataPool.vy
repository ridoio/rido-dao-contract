# @version 0.3.7
"""
@title Data Pool in airdrop stage
@author Pan
@license MIT
"""

struct AttestationAmount:
    epoch: uint64
    amount: uint64
    data_pool: bytes32


#f(s,x_j,n)= s \cdot \sum_{m=0}^{n-1} (\frac{t_1}{t_2})^m + (\frac{t_1}{t_2})^n \cdot (x_j-ns)
struct DataPoolSlope:
    t: decimal
    s: uint64
    reward: uint256


minter: public(address)
admin: public(address)
gaugeController: public(address)

# map(schema uid -> map(epoch -> data pool info))
pools: public(HashMap[bytes32, HashMap[uint64, DataPoolSlope]])

# map(schema uid -> map(epoch -> (total attestation amount)))
totalAttestations: public(HashMap[bytes32, HashMap[uint64, uint64]])

# map(user -> map(epoch->attestation numbers))
userAttestations: public(HashMap[address,HashMap[uint64,uint64]])

@external
def __init__():
    self.admin = msg.sender

@external
def set_minter(_minter: address):
    """
    @notice Set the minter address
    @dev Only callable once, when minter has not yet been set
    @param _minter Address of the minter
    """
    assert msg.sender == self.admin
    assert _minter != empty(address) 
    assert self.minter == empty(address) 
    self.minter = _minter

@external
def set_gauge_controller(_gauge_controller: address):
    """
    @notice Set the gauge controller address
    @dev Only callable once, when gauge controller has not yet been set
    @param _gauge_controller Address of the gauge controller
    """
    assert msg.sender == self.admin
    assert _gauge_controller != empty(address) 
    assert self.gaugeController == empty(address) 
    self.gaugeController = _gauge_controller

@external
def set_data_pools(_schemaUID: bytes32, _dataPoolSlope: DataPoolSlope,_epoch: uint64):
    """
    @notice Add or Set new data pool info
    @dev Only admin can call this function
    @param  _schemaUID UID of data pool
    @param _dataPoolSlope Slope information
    """
    assert msg.sender == self.gaugeController, "only gauage controller can add new data pool"
    self.pools[_schemaUID][_epoch] = _dataPoolSlope


@external
def update_each_epoch_attestations(_amounts: DynArray[AttestationAmount, 30]):
    """
    @notice Update total generated attestations amount in each epoch
    @dev Only admin can call this function
    @param _amounts Slice of the attestation info
        - Epoch: num of epoch
        - data_pool: data_pool uid
        - amount: amount of attestation generated in epoch `epoch` of data pool `data_pool`
    """

    assert msg.sender == self.admin

    for amount in _amounts:
       if self.totalAttestations[amount.data_pool][amount.epoch] == 0:
            self.totalAttestations[amount.data_pool][amount.epoch] = amount.amount


@external
def user_extractable_reward(_addr: address, _amounts: DynArray[AttestationAmount, 30],_sig: Bytes[65]) -> uint256:
    """
    @notice Update total generated attestations amount in each epoch
    @dev Only airdrop minter can call this function
    @param _addr the address you want to checkout the extractable
    @param _amounts Slice of the attestation info
        - Epoch: num of epoch
        - data_pool: data_pool uid
        - amount: amount of attestation generated by `_addr` in epoch `epoch` of data pool `data_pool`
    """
    assert msg.sender == self.minter
    extractableRIDO: uint256 = 0
    _hash: bytes32 = convert(_addr,bytes32)
    
    for amount in _amounts:
        _hash = keccak256(concat(
            _hash,
            convert(amount.epoch,bytes8),
            convert(amount.amount,bytes8),
            amount.data_pool,
        ))

    assert self.ecrecoverSig(_hash,_sig) == self.admin
    
    for amount in _amounts:
        if self.userAttestations[_addr][amount.epoch] != 0:
            continue
        else:
            _totalAttestations: uint64 = self.totalAttestations[amount.data_pool][amount.epoch]
            extractableRIDO += self.get_rate_of_pool(amount.amount,_totalAttestations,amount.data_pool,amount.epoch)

    return extractableRIDO


@internal
def ecrecoverSig(_hash: bytes32, _sig: Bytes[65]) -> address:
    """
    @dev Recover signer address from a message by using their signature
    @param _hash bytes32 message, the hash is the signed message. What is recovered is the signer address.
    @param _sig bytes signature, the signature is generated using web3.eth.sign()
    """
    if len(_sig) != 65:
        return empty(address)
    # ref. https://gist.github.com/axic/5b33912c6f61ae6fd96d6c4a47afde6d
    # The signature format is a compact form of:
    # {bytes32 r}{bytes32 s}{uint8 v}
    r: uint256 = extract32(_sig, 0, output_type=uint256)
    s: uint256 = extract32(_sig, 32, output_type=uint256)
    v: int128 = convert(slice(_sig, 64, 1), int128)
    # Version of signature should be 27 or 28, but 0 and 1 are also possible versions.
    # geth uses [0, 1] and some clients have followed. This might change, see:x
    # https://github.com/ethereum/go-ethereum/issues/2053
    if v < 27:
        v += 27
    if v in [27, 28]:
        return ecrecover(_hash, convert(v, uint256), r, s)
    return empty(address)
    

@internal
def get_rate_of_pool(_amount: uint64, _total: uint64, _data_pool: bytes32, _epoch: uint64) -> uint256:
    slope : DataPoolSlope =  self.pools[_data_pool][_epoch]
    n:uint64 = _amount / slope.s

    f: uint256 = self.piecewise_function(slope.s, slope.t, n, _amount)
    reward: uint256 = self.get_data_pool_info(_epoch,_data_pool)
    return f * reward / convert(self.totalAttestations[_data_pool][_epoch],uint256)


@internal
def piecewise_function(s: uint64,t: decimal, n: uint64, x: uint64) -> uint256:
    #f(s,x_j,n)= s \cdot \sum_{m=0}^{n-1} (\frac{t_1}{t_2})^m + (\frac{t_1}{t_2})^n \cdot (x_j-ns)
    _s: decimal = 0.0
    _ti: decimal = 1.0
    for i in range (9999999):
        if i >= n:
            break
        if i == 0:
            _ti = t
        else:
            _ti = _ti * t

        _s = _s + _ti

    #_ti = t^n
    _ti = _ti * t

    #_s = s * \sum^n-1_{i=0} t^i
    _s = convert(s, decimal) * _s
    
    result: uint256 = convert(_s + _ti * convert(x - n * s,decimal),uint256)
    return result

@internal
def get_data_pool_info(_epoch: uint64, _data_pool: bytes32) -> uint256:
    for i in range (999999999):
        if i > _epoch:
            break

        reward: uint256 = self.pools[_data_pool][_epoch-i].reward
        if reward != 0:
            if i != 0:
                self.pools[_data_pool][_epoch].reward = reward
            return reward
    return 0
    

    
